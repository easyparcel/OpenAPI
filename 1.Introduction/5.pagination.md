# Pagination Guide for EasyParcel API

This document outlines the pagination mechanism used in the EasyParcel API for endpoints that return multiple records, such as shipment listings and on-demand service listings.

## Pagination Overview

EasyParcel API uses cursor-based pagination for list endpoints. This method is more efficient than traditional page number-based pagination, especially for large datasets.

## How Pagination Works

1. You specify a limit of records to return in each request
2. The API returns records sorted by the latest first
3. To retrieve the next set of records, you use the last record's identifier as a cursor

## Pagination Parameters

| Parameter               | Type    | Required | Description                                       |
|------------------------|---------|----------|---------------------------------------------------|
| limit                  | integer | No       | Number of records to return (default: 10, max: 250)|
| before_shipment_number | string  | No       | ID of the record to paginate from                 |

Additionally, you can use filtering parameters along with pagination:

| Parameter               | Type    | Required | Description                                       |
|------------------------|---------|----------|---------------------------------------------------|
| shipment_status_code   | string  | No       | Filter by shipment status                         |
| date_from              | date    | No       | Start date for filtering (YYYY-MM-DD)             |
| date_to                | date    | No       | End date for filtering (YYYY-MM-DD)               |

## Pagination Example

### Initial Request

The first request does not include a `before_shipment_number` parameter:

```json
{
  "limit": 3,
  "shipment_status_code": "7",
  "date_from": "2025-04-01",
  "date_to": "2025-04-23"
}
```

### Subsequent Requests

For the next batch of records, include the `before_shipment_number` from the last record in the previous response:

```json
{
  "limit": 3,
  "before_shipment_number": "ES-2504-B944M",
  "shipment_status_code": "7",
  "date_from": "2025-04-01",
  "date_to": "2025-04-23"
}
```

## Implementation Guide

### Client-Side Pagination Logic

Here's a pseudocode example of how to implement pagination in your client application:

```javascript
// Initial request - no cursor
let params = {
  limit: 20,
  shipment_status_code: "7",
  date_from: "2025-04-01",
  date_to: "2025-04-23"
};

async function fetchAllShipments() {
  let allShipments = [];
  let hasMoreRecords = true;
  
  while (hasMoreRecords) {
    const response = await apiRequest('/shipment/list', params);
    
    // Add fetched shipments to our collection
    allShipments = [...allShipments, ...response.data];
    
    // If we received fewer records than requested, we've reached the end
    if (response.data.length < params.limit) {
      hasMoreRecords = false;
    } else {
      // Set cursor for next request using the last record's ID
      const lastShipment = response.data[response.data.length - 1];
      params.before_shipment_number = lastShipment.shipment_number;
    }
  }
  
  return allShipments;
}
```

### Loading Records On Demand

For user interfaces, you may want to implement "load more" functionality:

```javascript
let currentParams = {
  limit: 20,
  shipment_status_code: "7"
};

let shipments = [];

async function loadMoreShipments() {
  const response = await apiRequest('/shipment/list', currentParams);
  
  // Add new shipments to the existing list
  shipments = [...shipments, ...response.data];
  
  // Update button state
  const loadMoreButton = document.getElementById('load-more');
  if (response.data.length < currentParams.limit) {
    loadMoreButton.style.display = 'none'; // Hide when no more records
  } else {
    // Update cursor for next request
    const lastShipment = response.data[response.data.length - 1];
    currentParams.before_shipment_number = lastShipment.shipment_number;
  }
  
  // Update UI with new shipments
  renderShipments(shipments);
}
```

## Pagination for On-demand Listings

The on-demand listing endpoint follows the same pagination pattern as shipment listings:

```json
{
  "limit": 3,
  "before_booking_number": "OD-2504-ABCDE",
  "shipment_status_code": "7",
  "date_from": "2025-04-01",
  "date_to": "2025-04-23"
}
```

## Best Practices

1. **Default Limit**: If not specified, the API uses a default limit of 10 records per request
2. **Maximum Limit**: The maximum limit is 250 records per request
3. **Sort Order**: Results are always sorted with the most recent records first
4. **Filter Efficiency**: Use status and date filters to reduce the dataset before pagination
5. **Cursor Storage**: Always store the last cursor for error recovery
6. **Empty Results**: If a request returns empty results, you've reached the end of the dataset

## Common Issues and Solutions

| Issue                                   | Solution                                            |
|-----------------------------------------|-----------------------------------------------------|
| Missing records in pagination sequence  | Ensure you're using the correct cursor value        |
| Too many API calls for large datasets   | Increase the limit parameter (up to 250)            |
| Need to restart pagination from beginning | Remove the before_shipment_number parameter       |
| Results not matching expected criteria  | Review filter parameters for correct formatting     |

## Notes on Resource Usage

- Using appropriate limit values and filters helps reduce API calls
- Retrieving all records in smaller batches is more reliable than requesting large batches
- Consider implementing caching for frequently accessed records
